package fn

// ===================================================
//                      List
// ===================================================

// Map applies a function to each element of a slice and returns a new slice with the results.
func Map[T, R any](xs []T, fn func(x T, i int) R) []R {
	var ys = make([]R, 0, len(xs))

	for i, x := range xs {
		ys = append(ys, fn(x, i))
	}

	return ys
}

// Reduce applies an accumulator function to each element of a slice and returns the final accumulator value.
func Reduce[T, R any](xs []T, fn func(x T, i int, acc R) R) R {
	var acc R

	for i, x := range xs {
		acc = fn(x, i, acc)
	}

	return acc
}

// Fold applies an accumulator function to each element of a slice and an accumulator and returns the final accumulator value.
func Fold[T, R any](xs []T, z R, fn func(x T, i int, acc R) R) R {
	var acc = z

	for i, x := range xs {
		acc = fn(x, i, acc)
	}

	return acc
}

// Filter returns a new slice with only the elements that satisfy a predicate function.
func Filter[T any](xs []T, fn func(x T, i int) bool) []T {
	var ys = make([]T, 0, len(xs))

	for i, x := range xs {
		if fn(x, i) {
			ys = append(ys, x)
		}
	}

	return ys
}

// Zip returns a new slice with the elements of two slices combined into pairs.
func Zip[A, B any](a []A, b []B) []Pair[A, B] {
	var n = len(a)
	if len(b) < n {
		n = len(b)
	}

	var pairs = make([]Pair[A, B], 0, n)

	for i := 0; i < n; i++ {
		pairs = append(pairs, NewPair(a[i], b[i]))
	}

	return pairs
}

// All returns true if all elements of a slice satisfy a predicate function.
func All[T any](xs []T, fn func(x T, i int) bool) bool {
	for i, x := range xs {
		if !fn(x, i) {
			return false
		}
	}

	return true
}

// Any returns true if any elements of a slice satisfies the predicate
func Any[T any](xs []T, fn func(x T, i int) bool) bool {
	for i, x := range xs {
		if fn(x, i) {
			return true
		}
	}

	return false
}

// Find returns the first element that satisfies the predicate function
// Returns None if no element satisfies the predicate
func Find[T any](xs []T, fn func(x T, i int) bool) Option[Pair[T, int]] {
	for i, x := range xs {
		if fn(x, i) {
			return Some(NewPair(x, i))
		}
	}

	return None[Pair[T, int]]()
}

// FindLast returns the last element that satisfies the predicate function
// Returns None if no element satisfies the predicate
func FindLast[T any](xs []T, fn func(x T, i int) bool) Option[Pair[T, int]] {
	for i := len(xs) - 1; i >= 0; i-- {
		if fn(xs[i], i) {
			return Some(NewPair(xs[i], i))
		}
	}

	return None[Pair[T, int]]()
}

// Associate returns a map of keys to values
// The keys are generated by the function fn
func Associate[T any, K comparable](xs []T, fn func(x T, i int) K) map[K]T {
	var m = make(map[K]T)

	for i, x := range xs {
		m[fn(x, i)] = x
	}

	return m
}

// ===================================================
//                      Map
// ===================================================

// Keys returns a new slice with the keys of a map
func Keys[K comparable, V any](m map[K]V) []K {
	var keys = make([]K, 0, len(m))

	for k := range m {
		keys = append(keys, k)
	}

	return keys
}

// Values returns a new slice with the values of a map
func Values[K comparable, V any](m map[K]V) []V {
	var values = make([]V, 0, len(m))

	for _, v := range m {
		values = append(values, v)
	}

	return values
}

// MapToSlice applies a function to each key-value pair of a map and returns a new slice with the results.
func MapToSlice[K comparable, V, R any](m map[K]V, f func(k K, v V) R) []R {
	var rs = make([]R, 0, len(m))

	for k, v := range m {
		rs = append(rs, f(k, v))
	}

	return rs
}
